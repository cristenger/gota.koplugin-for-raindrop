--[[
    Article Manager Module for Gota Plugin
    Handles all article-related operations: viewing, downloading, opening in reader
]]

local DataStorage = require("datastorage")
local UIManager = require("ui/uimanager")
local logger = require("logger")
local util = require("util")
local _ = require("gettext")

local ArticleManager = {}

function ArticleManager:new(api, content_processor, gota_reader, callbacks)
    local o = {}
    setmetatable(o, self)
    self.__index = self
    
    o.api = api
    o.content_processor = content_processor
    o.gota_reader = gota_reader
    o.callbacks = callbacks  -- notify, showProgress, hideProgress
    o.settings = nil  -- Se establecerá después
    
    return o
end

function ArticleManager:setSettings(settings)
    self.settings = settings
end

-- ========== ARTICLE CONTENT LOADING ==========

-- Carga el contenido completo de un artículo con caché
function ArticleManager:loadFullArticle(raindrop)
    if raindrop.cache then
        return raindrop, nil
    end
    
    self.callbacks.showProgress(_("Cargando contenido completo..."))
    local full_raindrop, err = self.api:getRaindrop(raindrop._id)
    self.callbacks.hideProgress()
    
    if full_raindrop and full_raindrop.item then
        return full_raindrop.item, nil
    end
    
    return raindrop, err
end

-- Carga el contenido del caché si no está presente
function ArticleManager:loadCacheContent(raindrop)
    -- Si ya tiene texto o no hay caché, no hacer nada
    if not raindrop.cache or raindrop.cache.text then
        return raindrop
    end
    
    -- Si el caché no está listo, no intentar cargarlo
    if raindrop.cache.status ~= "ready" then
        logger.dbg("ArticleManager: Caché no está listo, status:", raindrop.cache.status)
        return raindrop
    end
    
    self.callbacks.showProgress(_("Cargando contenido en caché..."))
    local cache_content, err = self.api:getRaindropCache(raindrop._id)
    self.callbacks.hideProgress()
    
    if cache_content and type(cache_content) == "string" and #cache_content > 0 then
        raindrop.cache.text = cache_content
        logger.dbg("ArticleManager: Contenido HTML cargado, longitud:", #cache_content)
    else
        -- Si falla la carga, registrar el error
        logger.warn("ArticleManager: No se pudo cargar caché:", err or "contenido vacío")
        -- NO establecer texto por defecto, dejar que hasValidCache retorne false
    end
    
    return raindrop
end

-- Verifica si un artículo tiene caché disponible
function ArticleManager:hasValidCache(raindrop)
    -- Primero verificar que existe el objeto cache
    if not raindrop.cache then
        return false
    end
    
    -- El caché solo es válido si status == "ready"
    if raindrop.cache.status ~= "ready" then
        return false
    end
    
    -- Si ya tenemos el texto cargado, verificar que tenga contenido útil
    if raindrop.cache.text then
        return #raindrop.cache.text >= 50
    end
    
    -- Si no tenemos texto pero status == "ready" y size > 0, 
    -- significa que está disponible para descarga
    return raindrop.cache.size and raindrop.cache.size > 0
end

-- ========== ARTICLE RELOADING ==========

function ArticleManager:reloadArticle(raindrop_id, on_success_callback)
    self.callbacks.showProgress(_("Recargando artículo..."))
    local full_raindrop, err = self.api:getRaindrop(raindrop_id)
    self.callbacks.hideProgress()
    
    if full_raindrop and full_raindrop.item then
        if full_raindrop.item.cache and 
           full_raindrop.item.cache.status == "ready" and 
           full_raindrop.item.cache.text then
            on_success_callback(full_raindrop.item)
        else
            self.callbacks.notify(_("El artículo aún no tiene contenido en caché disponible"))
            on_success_callback(full_raindrop.item)
        end
    else
        self.callbacks.notify(_("Error al recargar artículo: ") .. (err or _("Error desconocido")))
    end
end

-- ========== DOWNLOAD HTML ==========

function ArticleManager:downloadHTML(raindrop)
    if not raindrop._id then
        self.callbacks.notify(_("No se puede descargar: ID no encontrado"))
        return nil
    end
    
    if not raindrop.cache or raindrop.cache.status ~= "ready" then
        self.callbacks.notify(_("No hay contenido en caché disponible para descargar"))
        return nil
    end
    
    -- Obtener directorio configurado
    local html_dir = self.settings:getFullDownloadPath()
    if not util.makePath(html_dir) then
        self.callbacks.notify(_("Error al crear directorio para guardar HTML"))
        return nil
    end
    
    -- Nombre de archivo seguro
    local safe_title = (raindrop.title or "article"):gsub("[%c%p%s]", "_"):sub(1, 30)
    local filename = html_dir .. raindrop._id .. "_" .. safe_title .. ".html"
    
    -- Descargar contenido
    self.callbacks.showProgress(_("Descargando HTML..."))
    local html_content, err = self.api:getRaindropCache(raindrop._id)
    self.callbacks.hideProgress()

    if not html_content or type(html_content) ~= "string" then
        self.callbacks.notify(_("Error al descargar HTML: ") .. (err or "Respuesta inválida"))
        return nil
    end
        
    if #html_content < 100 then
        self.callbacks.notify(_("El contenido descargado parece incompleto"))
        return nil
    end
    
    -- Guardar archivo
    local file, file_err = io.open(filename, "wb")
    if not file then
        self.callbacks.notify(_("Error al crear archivo: ") .. tostring(file_err))
        return nil
    end
    
    file:write(html_content)
    file:close()
    
    logger.dbg("ArticleManager: HTML guardado:", filename)
    self.callbacks.notify(string.format(_("HTML guardado en: %s"), filename), 5)
    
    return filename
end

-- ========== OPEN IN READER ==========

function ArticleManager:openInReader(raindrop, close_all_callback, on_return_callback)
    -- Cerrar todos los widgets antes de abrir
    close_all_callback()
    
    if not raindrop or not raindrop.cache or not raindrop.cache.text then
        self.callbacks.notify(_("No hay contenido disponible"))
        return false
    end
    
    -- Usar el mismo directorio configurado que para descargas
    local html_dir = self.settings:getFullDownloadPath()
    local lfs = require("libs/libkoreader-lfs")
    if not lfs.attributes(html_dir, "mode") then
        util.makePath(html_dir)
    end
    
    -- Crear archivo HTML con nombre único
    local safe_title = (raindrop.title or "article"):gsub("[%c%p%s]", "_"):sub(1, 30)
    local filename = html_dir .. raindrop._id .. "_" .. safe_title .. "_temp.html"
    local html = self.content_processor:createReaderHTML(raindrop)
    
    local file = io.open(filename, "w")
    if not file then
        self.callbacks.notify(_("Error al crear archivo temporal"))
        return false
    end
    
    file:write(html)
    file:close()
    
    -- Usar GotaReader para abrir
    self.gota_reader:show({
        path = filename,
        raindrop = raindrop,
        on_return_callback = function()
            logger.dbg("ArticleManager: Usuario volvió del lector")
            UIManager:scheduleIn(0.2, function()
                on_return_callback(raindrop)
            end)
        end,
    })
    
    return true
end

-- ========== OPEN DOWNLOAD FOLDER ==========

function ArticleManager:openDownloadFolder(filename, close_all_callback)
    close_all_callback()
    
    local FileManager = require("apps/filemanager/filemanager")
    local folder_path = filename:match("(.+)/[^/]+$")
    
    if FileManager.instance then
        FileManager.instance:reinit(folder_path)
    else
        FileManager:showFiles(folder_path)
    end
end

return ArticleManager
